<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="OpenGL学习记录--入门章节, YoKuYou">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>OpenGL学习记录--入门章节 | YoKuYou</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">YoKuYou</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">YoKuYou</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">OpenGL学习记录--入门章节</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/OpenGL/">
                                <span class="chip bg-color">OpenGL</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2020-03-19
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="窗口创建和初始化"><a href="#窗口创建和初始化" class="headerlink" title="窗口创建和初始化"></a>窗口创建和初始化</h3><p>　　在开启窗口之前，需要先初始化GLFW，用<code>glfwWindowHint（）</code>函数去指定使用的OpenGL的版本号,还需要告诉GLFW使用的核心模式。实例化窗口之后用<code>glfwMakeContextCurrent（）</code>去把当前窗口设置为当前线程主窗口。再使用<code>processInput（）</code>函数在用户拖动窗口大小时同时改变渲染窗口的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> region Init And Open Window</span></span><br><span class="line">	glfwInit();</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">	GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Sword Art Online&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SAO World Failed&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Init GLAD Failed&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> endregion</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h3><p>　　所有的渲染指令全部放到渲染循环之中，使用<code>glClear（）</code>来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲，可能的缓冲位有<code>GL_COLOR_BUFFER_BIT</code>，<code>GL_DEPTH_BUFFER_BIT</code>和<code>GL_STENCIL_BUFFER_BIT</code>。调用了<code>glClearColor()</code>来设置清空屏幕所用的颜色。当调用<code>glClear()</code>，清除颜色缓冲之后，整个颜色缓冲都会被填充为<code>glClearColor()</code>里所设置的颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">	processInput(window);</span><br><span class="line"></span><br><span class="line">	glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glfwSwapBuffers(window);</span><br><span class="line">	glfwPollEvents();</span><br><span class="line">&#125;</span><br><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure>

<p><code>glfwSwapBuffers()</code>是用于交换颜色缓冲，是因为现在使用渲染窗口绘图时都是采用双缓冲（Double Buffer）的方式，消除了单缓冲带来的不真实感。</p>
<p><code>glfwPollEvents()</code>用来返回用户的输入。</p>
<hr>
<h3 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h3><p>　　图形渲染管线其实就是把一大堆3D的数据转化为屏幕上的2D像素，所有的渲染都是通过这个管线将你想让它出现的东西最终出现在屏幕上。图形渲染管线有几个阶段，每个阶段都把前一个阶段的结果（输入）拿来操作，并且这些操作具有并行性，所以大多数显卡都有成千上万的小处理核心(并行性也是GPU速度很快的原因)，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理数据。这些小程序就叫做着色器(Shader)，它们运行在GPU上，并且有的着色器可以由我们来编程控制。</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/tube.png" class="">

<blockquote>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：<code>GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP</code>。</p>
</blockquote>
<h4 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器 Vertex Shader"></a>顶点着色器 Vertex Shader</h4><p>　　所有的顶点数据都会进入Vertex Shader中，它的功能是把输入的数据进行矩阵变换位置，计算光照公式生成逐顶点颜⾊，⽣成/变换纹理坐标。并为所输入的数据确定属性，把它们具体区分为点的空间位置、面的法向量、纹理坐标或者颜色。</p>
<h4 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器 Geometry Shader"></a>几何着色器 Geometry Shader</h4><p>　　通过Shader程序可以指定Geometry Shader对顶点信息进行增减。因为实际增减的是复数的顶点，所以对各种的线段、多边形、粒子等图元也可以进行增减。它可以通过增加顶点让边和面变得更加平滑。</p>
<h4 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h4><p>　　就是通过坐标变换等操作将3D的数据转化成像素在屏幕上显示。</p>
<h4 id="片段着色器-Fragment-Shader"><a href="#片段着色器-Fragment-Shader" class="headerlink" title="片段着色器 Fragment Shader"></a>片段着色器 Fragment Shader</h4><p>　　主要目的是计算一个像素的最终颜色，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据都会被用来计算最终像素的颜色，很多高级的效果都在这里实现。</p>
<hr>
<h3 id="VBO-amp-VAO"><a href="#VBO-amp-VAO" class="headerlink" title="VBO&amp;VAO"></a><strong>VBO&amp;VAO</strong></h3><p>　　CPU在得到.obj的顶点数据之后，就进入了顶点着色器的阶段，CPU会把这些数据送给GPU，GPU就会创建内存去存储这些数据，而VBO(Vertex Buffer Objects)就是用来存储的Buffer，它会在GPU内存中储存大量顶点。使用这些缓冲对象的好处是可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</p>
<p>　　VAO(Vertex Array Object)顶点数组对象就相当于是一个索引，它用于对这些顶点数据进行解析，分析出里面哪些是描述的空间位置，哪些描述的是法线或者颜色。VAO可以绑定两种Buffer，一种是ArrayBuffer一种是ElementBuffer。</p>
<blockquote>
<p>ＯpenGL的核心模式要求我们必须使用VAO，它知道该如何处理顶点输入。如果绑定VAO失败，OpenGL会拒绝绘制任何东西。</p>
<p>VAO和VBO是一一对应的，一个模型的数据输入（一套完整独立的数据）对应一个VAO</p>
</blockquote>
<p>​        我们可以同时创建多个VBO和EBO，它们都可以与VAO进行绑定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ShaderProgram"><a href="#ShaderProgram" class="headerlink" title="ShaderProgram"></a>ShaderProgram</h3><p>　　OpenGL的着色器是使用GLSL写的，是一种类C语言，在需要编译Shader时可以采用文件读取，也可以硬编码在字符串中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource =</span><br><span class="line"><span class="string">&quot;	#version 330 core \n									  &quot;</span></span><br><span class="line"><span class="string">&quot;	layout(location = 0) in vec3 aPos;\n					   &quot;</span></span><br><span class="line"><span class="string">&quot;	void main()\n											 &quot;</span></span><br><span class="line"><span class="string">&quot;	&#123;\n														&quot;</span></span><br><span class="line"><span class="string">&quot;		gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125;\n		&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource =</span><br><span class="line"><span class="string">&quot;	#version 330 core \n                                      &quot;</span></span><br><span class="line"><span class="string">&quot;	out vec4 FragColor;\n								   &quot;</span></span><br><span class="line"><span class="string">&quot;	void main()\n										  &quot;</span></span><br><span class="line"><span class="string">&quot;	&#123;\n													 &quot;</span></span><br><span class="line"><span class="string">&quot;		FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125;\n		&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>　　在VertexShader里面，<code>layout (location = 0)</code>设定了输入变量的位置值，它决定了输入数据在VAO中的位置。它与<code>glVertexAttribPointer()</code>函数的第一个参数是对应的，代表着顶点属性的位置，在OpenGL中它能提供的位置为0~15。</p>
<p>　　我们使用<code>glCreateShader()</code>来创建Shader，这个函数要指明Shader的类型，然后使用<code>glShaderSource()</code>函数把着色器的源码给加载到这个着色器对象上，这个函数把要编译的着色器对象作为第一个参数，第二参数指定了传递的源码字符串数量，第三个参数是顶点着色器的源码。下面分别创建VertexShader和FragmentShader：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>接着就是将刚刚创建好的两个shader拿来一起编译，用<code>glCreateProgram()</code>取得创建的Program的编号，然后分别将之前的顶点着色器和片段着色器附加到上面，最后再连接编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line">glAttachShader(shaderProgram,vertexShader);</span><br><span class="line">glAttachShader(shaderProgram,fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>每当你想要绘制一个物体时，你都需要先绑定对应的VAO，然后再调用之前的ShaderProgram。还需要使用<code>glVertexAttribPointer()</code>函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）。这里就是指从第零个开始挖数据，每三个为一组，即每隔三个挖出一组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定，加载源代码</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//绘制，在While循环中</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>完成以上代码就可以绘制出OpenGL中最基础的三角形：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png" class="">

<p>可喜可贺！！！</p>
<p>但是在这里我们需要多提一下，如果我们把顶点增加为六个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.8f</span>,  <span class="number">0.8f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时画出的是一个四边形：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png" class="">

<p>　　但是OpenGL默认的三角形的绘制顺序是逆时针，也就是说我们新增的那三个顶点所画出的那个三角形其实是背面，为了验证我们加两行代码，打开OpenGL的背面剔除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure>

<p>　　这时再次运行就只有最初的那一个三角形在，同理，你变成剔除正面：GL_FRONT，这时左边的三角形就不会被画出来。</p>
<hr>
<h3 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h3><p>　　不需要六个点，只用四个点就可以画出四边形，我们就需要EBO，索引缓冲对象(Element Buffer Object，EBO。它实际上是给出了点的绘制顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//0</span></span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//1</span></span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//2</span></span><br><span class="line">	 <span class="number">0.8f</span>,  <span class="number">0.8f</span>,  <span class="number">0.0f</span>,<span class="comment">//3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们只需要按照：012  213的顺序，就可以只指定四个点画出一个四边形。</p>
<blockquote>
<p>EBO里实际上就存储的是一个绘制顺序的索引</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="comment">//第一个三角形</span></span><br><span class="line">	<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span><span class="comment">//第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>　　在OpenGL中都任何当前运行的Context，都只会处理当前的一个VAO，同时状态机也只会处理VAO去Bind一个VBO。在运行时，需要首先指定一个VAO到当前Context，然后把你想操作的VBO去绑定当前的ArrayBuffer，当VAO处理完这个VBO里的数据之后，你可以UnBind，然后把比如说另一个把存有法线数据的VBO给Bind到当前VAO，然后继续处理，所以一个当前要画的VAO可以和多个VBO去合作。EBO也是在创建之后与当前上下文中的VAO绑定，然后绘制的时候用引索的方式去画就ok：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">glBindBuffer(<span class="number">1</span>, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//while中：</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>VAO、VBO、EBO的绑定在一开始申明时绑了就行，不需要在渲染循环里面多次绑定。</p>
</blockquote>
<p>这样就使用另外一种方法画出了这个四边形。可喜可贺！！!   :smiley:</p>
<hr>
<h3 id="入门篇的重点！！！Shader"><a href="#入门篇的重点！！！Shader" class="headerlink" title="入门篇的重点！！！Shader"></a>入门篇的重点！！！Shader</h3><p>　　Shader：运行在GPU上的小程序，是用GLSL写成的小程序。着色器的开头要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中处理所有的输入变量，并将结果输出到输出变量中。GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。</p>
<p>　　在顶点着色器中接受的是特殊输入，他是从模型的顶点数据中直接接受输入，需要使用layout去指定顶点数据的position，我们能声明的顶点数据位置是有上限的，它一般由硬件来决定。OpenGL有16个包含4分量的顶点属性可用（0~15），但是有些硬件或许允许更多的顶点属性，可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限。而片段着色器必须要一个vec4的颜色输出值，它接受顶点着色器的输入的变量必须与顶点着色器的输出同名。</p>
<blockquote>
<p>当然也可以忽略<code>layout (location = 0)</code>标识符，通过在OpenGL代码中使用glGetAttribLocation查询属性位置值(Location)</p>
</blockquote>
<p>　　而Uniform是一种从CPU中直接向GPU中的着色器发送数据的方式。它是全局的，意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。而且无论把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。下面就是它的使用方法,我们首先在片段着色器里面定义一句<code>uniform vec4 ourColor</code>，然后把ourColor设置为输出颜色，然后我们在main函数里面去调变它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);<span class="comment">//取得uniform的位置</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0</span>, greenValue, <span class="number">0</span>, <span class="number">1.0f</span>);<span class="comment">//给uniform赋值</span></span><br><span class="line"></span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>然后就可以得到一个颜色随时间变化的三角形。</p>
<p>下面我们再提高一下VAO挖数据的熟练度，我们可以给每个顶点数据增加一个颜色数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//顶点              //颜色</span></span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">0</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>,</span><br><span class="line">	 <span class="number">0.8f</span>,  <span class="number">0.8f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.7f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>　　于是在挖顶点的相关代码中我们就要做一些改变，对于挖顶点的Attribute，我们需要改变它每次挖的步长，由于增加了三个颜色数据，现在需要挖完一组后从刚刚的起始隔六个float再挖，对于挖颜色的Attibute要设置从不同于0号的位置开始挖，然后也是挖完一组后从刚刚的起始位置隔六个float再开始挖下一组，至于最后一个参数，它的意思是初始位置的偏移量，第二个Attribute的意思就是第一组跳过前三个，从第四个开始挖：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span>* <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对于一个顶点着色器，可以有多个VAO去用它的位置，或许还有一组描述箱子的顶点坐标，你也要用同样的代码去把箱子的顶点坐标存在0号位，但是肯就会疑惑，为什么它重复使用了同一个顶点着色器里面的location，之前不是已经传过数据了吗？但是你仔细想想，它并没有重复，因为每创建一个VAO，你就使用了顶点着色器里面的locaion，然后去解析了数据，然后就存在了VAO之中，顶点着色器里面的lacation斌并有用来存数据，他只是一个指示，来把数据解析然后存在VAO中，所以重复使用位置不是什么奇怪的事。</span></span><br></pre></td></tr></table></figure>

<p>　　同时我们需要在顶点着色器中指定颜色坐标的输入：<code>layout(location = 1) in vec3 aColor</code>。然后把它赋予输入到片段着色器的颜色数据。最后在片段着色器中把输出颜色改为接收到的顶点着色器的输出颜色。</p>
<p>就可以得到下面的效果：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png" class="">

<hr>
<h3 id="创建着色器类，从外部读取Shader代码！！重要重要"><a href="#创建着色器类，从外部读取Shader代码！！重要重要" class="headerlink" title="创建着色器类，从外部读取Shader代码！！重要重要"></a>创建着色器类，从外部读取Shader代码！！重要重要</h3><p>　　在创建我们自己的着色器类时，我们想要从硬盘里面读取Shader代码（如果总是把Shader代码硬编码在main函数里会很不方便修改与Debug），这时由于CPU和硬盘处理速度的原因，我们希望在主存里面设置一个Buffer去存储从硬盘中读取的文件，然后让CPU去进行处理。还有一个点就是我们读到的其实是String，然而 OpenGL支持的是字符数组，所以我们还需要去Cast String。这就需要用到C++的字符串的处理和文件读取的一些知识，要用到C++中流概念。</p>
<p>　　我们的想法是创建一个shader.h的类，在它的构造函数的参数中给出顶点着色器和片段着色器的文件路径，通过ifstream流去读取打开文件，然后用rdbuf()函数去读取文件中的内容。然后用str()转成string类型保存到stringsteam类型的变量中，最后用c_str()函数把string转成char* 类型。</p>
<p>shader.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Shader(<span class="keyword">const</span> <span class="keyword">char</span>* vertexPath, <span class="keyword">const</span> <span class="keyword">char</span>* fragmentPath);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> vertexString;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> fragmentString;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* vertexSource = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* fragmentSource = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ID;<span class="comment">//创建的Program的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CheckCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shader.cpp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::ifstream vertexFile;</span><br><span class="line"><span class="built_in">std</span>::ifstream fragmentFile;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> vertexSStream;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> fragmentSString;</span><br><span class="line"></span><br><span class="line">vertexFile.open(vertexPath);</span><br><span class="line">fragmentFile.open(fragmentPath);</span><br><span class="line"></span><br><span class="line">vertexSStream &lt;&lt; vertexFile.rdbuf();</span><br><span class="line">fragmentSString &lt;&lt; fragmentFile.rdbuf();</span><br><span class="line"></span><br><span class="line">vertexString = vertexSStream.str();</span><br><span class="line">fragmentString = fragmentSString.str();</span><br><span class="line"></span><br><span class="line">vertexSource = vertexString.c_str();</span><br><span class="line">fragmentSource = fragmentString.c_str();</span><br></pre></td></tr></table></figure>

<p>然后我们用与之前一样的步骤去创建program就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertex, fragment;</span><br><span class="line">vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">glShaderSource(vertex, <span class="number">1</span>, &amp;vertexSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertex);</span><br><span class="line">CheckCompileErrors(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line">fragment = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragment, <span class="number">1</span>, &amp;fragmentSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragment);</span><br><span class="line">CheckCompileErrors(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line"></span><br><span class="line">ID = glCreateProgram();</span><br><span class="line">glAttachShader(ID, vertex);</span><br><span class="line">glAttachShader(ID, fragment);</span><br><span class="line">glLinkProgram(ID);</span><br><span class="line">CheckCompileErrors(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用shader类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader* myShader = <span class="keyword">new</span> Shader(<span class="string">&quot;vertexSource.txt&quot;</span>, <span class="string">&quot;fragmentSource.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="增加错误提示代码"><a href="#增加错误提示代码" class="headerlink" title="增加错误提示代码"></a>增加错误提示代码</h3><p>这里来说一下增加shader代码的错误提示功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::CheckCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ID, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> success;</span><br><span class="line">	<span class="keyword">char</span> infoLog[<span class="number">520</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type!=<span class="string">&quot;PROGRAM&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		glGetShaderiv(ID, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">		<span class="keyword">if</span> (!success)</span><br><span class="line">		&#123;</span><br><span class="line">			glGetShaderInfoLog(ID, <span class="keyword">sizeof</span>(infoLog), <span class="literal">NULL</span>, infoLog);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Shader Compile Error:&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line">		<span class="keyword">if</span> (!success)</span><br><span class="line">		&#123;</span><br><span class="line">			glGetProgramInfoLog(ID, <span class="keyword">sizeof</span>(infoLog), <span class="literal">NULL</span>, infoLog);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Program Linking Error:&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="纹理-汇入stb-image-h图像处理库"><a href="#纹理-汇入stb-image-h图像处理库" class="headerlink" title="纹理(汇入stb_image.h图像处理库)"></a>纹理(汇入stb_image.h图像处理库)</h3><p>　　纹理是一个非常重要的东西，可以给物体增加很多细节，它能够赋予物体，是因为有纹理坐标（uv坐标）这个东西。依据纹理坐标在纹理上进行剪裁，纹理坐标规定了物体的每个顶点对应纹理的哪个部分，这样就可以把纹理完美的贴在物体上。</p>
<h4 id="纹理环绕方式（结合Unity，wrap-mode）"><a href="#纹理环绕方式（结合Unity，wrap-mode）" class="headerlink" title="纹理环绕方式（结合Unity，wrap mode）"></a>纹理环绕方式（结合Unity，wrap mode）</h4><p>　　在图片导入unity时，引擎会自动把你的图片大小拉成2^n×2^n，相应的设置对应Unity的Non Power of 2选项。纹理的默认范围是0~1，当tiling是x=1，y=1时，warp mode没有任何影响，但是当纹理的tiling大于1，一张贴图不够大时，它如何处理边缘和外面的纹理生成方式就与wrap mode相关了，repeat模式就是重复整张贴图，clamp是在边缘找相近颜色然后来替代，就会产生一种拉伸的效果，mirror就是每贴一次去翻转uv坐标。</p>
<h4 id="纹理创建方式"><a href="#纹理创建方式" class="headerlink" title="纹理创建方式"></a>纹理创建方式</h4><p>　　在这里我们直接开始做如何给物体上多个纹理，首先在顶点着色器中要去接收纹理坐标的输入：<code>layout(location = 2) in vec2 aTexCoord;TexCoord = aTexCoord</code>，将纹理坐标TexCoord输出给片段着色器。在片段着色器里面，我们设置两个uniform变量去储存纹理。然后对于片段着色器的输出，我们改为用mix方法输出一个混合，<code>FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2)</code>。完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core 								</span></span><br><span class="line">layout(location = <span class="number">0</span>) in vec3 aPos;				</span><br><span class="line">layout(location = <span class="number">1</span>) in vec3 aColor;   </span><br><span class="line">layout(location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor;     </span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>										</span></span><br><span class="line"><span class="function"></span>&#123;														</span><br><span class="line">	gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">    vertexColor = vec4(aColor.xyz,<span class="number">1.0</span>);    </span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core                                      </span></span><br><span class="line">in vec4 vertexColor;     </span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">out vec4 FragColor;			</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>												</span></span><br><span class="line"><span class="function"></span>&#123;														</span><br><span class="line">	FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;	                  </span><br></pre></td></tr></table></figure>

<p>对于VBO数据的改变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">	<span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">		 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们又得重新设置Attribute去对数据进行解释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//要注意位置一定要与顶点着色器中layout设置的位置一致。</span></span><br></pre></td></tr></table></figure>

<p>然后就是使用纹理的一般步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> TexbufferA;<span class="comment">//定义纹理位置</span></span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;TexbufferA);<span class="comment">//生成</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);<span class="comment">//激活纹理单元，这里后面的数字是你加载的纹理所存放的位置，等会儿把这个位置给纹理采样器就可以让纹理采样器得到这个纹理</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, TexbufferA);<span class="comment">//绑定到刚刚激活的纹理单元</span></span><br><span class="line"><span class="comment">//这里可以去设置一些特殊的东西，比如说环绕方式，过滤方式。。。</span></span><br><span class="line"><span class="comment">//加载图片</span></span><br><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);<span class="comment">//反转Y轴，OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannel;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannel, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">	glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB,   		      GL_UNSIGNED_BYTE, data);<span class="comment">//默认将图片加载刚刚生成的纹理单元上</span></span><br><span class="line">	glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Load Image Failed&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);<span class="comment">//释放数据</span></span><br><span class="line"><span class="comment">//通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元，着色采样器就是在片段着色器里面uniform的那个东西,设置uniform的方法就是取得或者设定他的位置。</span></span><br><span class="line">myShader-&gt;use();</span><br><span class="line">glUniform1i(glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">glUniform1i(glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;texture2&quot;</span>), <span class="number">1</span>);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//这里的设置的采样器（uniform）的位置就是让采样器可以访问这个位置中所存放的纹理</span></span><br></pre></td></tr></table></figure>

<p>这样就可以得到两个纹理混合之后的效果，Texture is awesome！！</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png" class="">

<hr>
<h3 id="变换与坐标系统"><a href="#变换与坐标系统" class="headerlink" title="变换与坐标系统"></a>变换与坐标系统</h3><p>　　这一小节的关于线性代数的知识，最好去深刻地理解，不要去听大学老师给你讲，学不到什么本质，推荐去看<strong>3Blue1Brown</strong>的线性代数的本质，想要打好图形学基础的话最好微积分的本质也要去看一下（这个up的知识普及视频都挺好看的，可以知道很多很酷的知识）。还有个必须要看的就是闫令琪101图形学入门课程的transform章节，里面详细讲了关于坐标与变换的知识。为了后面的实践，我们先下载glm这个图形库。</p>
<p>　　为了实现对物体的变换，我们需要在顶点着色器里面定义一个Uniform的mat4矩阵变量，然后在main函数里面赋值之后乘上顶点输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core 								</span></span><br><span class="line">layout(location = <span class="number">0</span>) in vec3 aPos;				</span><br><span class="line">layout(location = <span class="number">1</span>) in vec3 aColor;   </span><br><span class="line">layout(location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor;     </span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>										</span></span><br><span class="line"><span class="function"></span>&#123;														</span><br><span class="line">	gl_Position = transform * vec4(aPos, <span class="number">1.0</span>);<span class="comment">//变换顶点</span></span><br><span class="line">    vertexColor = vec4(aColor.xyz,<span class="number">1.0</span>);    </span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数里面，取得uniform位置后进行调变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line"><span class="comment">//分别去位移旋转缩放</span></span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">-0.1f</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">45.0f</span>), glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>));</span><br><span class="line"><span class="comment">//在渲染循环里面去赋给uniform值</span></span><br><span class="line">glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));<span class="comment">//第一个参数永远是要查的uniform所在的shader的id号</span></span><br></pre></td></tr></table></figure>

<h4 id="构造变换矩阵（MVP）"><a href="#构造变换矩阵（MVP）" class="headerlink" title="构造变换矩阵（MVP）"></a>构造变换矩阵（MVP）</h4><p>为了将坐标从一个坐标系变换到另一个坐标系，需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。这里我们就去构造这样的三个矩阵，去把之前的3D转化到屏幕空间。</p>
<p>首先是在main函数中设置的三个变换矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 modelMat, viewMat, projMat;</span><br><span class="line">modelMat = glm::rotate(modelMat, glm::radians(<span class="number">-55.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">viewMat = glm::translate(viewMat, glm::vec3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-3.0f</span>));</span><br><span class="line">projMat = glm::perspective(glm::radians(<span class="number">45.0f</span>), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>

<p>然后在顶点着色器中设置三个相对应的uniform变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core 								</span></span><br><span class="line">layout(location = <span class="number">0</span>) in vec3 aPos;				</span><br><span class="line">layout(location = <span class="number">1</span>) in vec3 aColor;   </span><br><span class="line">layout(location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 modelMat;</span><br><span class="line">uniform mat4 viewMat;</span><br><span class="line">uniform mat4 projMat;</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor;     </span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>										</span></span><br><span class="line"><span class="function"></span>&#123;														</span><br><span class="line">	gl_Position = projMat * viewMat * modelMat * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    vertexColor = vec4(aColor.xyz,<span class="number">1.0</span>);    </span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在渲染循环里面去设置给对应的uniform赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;modelMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(modelMat));</span><br><span class="line">glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;viewMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(viewMat));</span><br><span class="line">glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;projMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(projMat));</span><br></pre></td></tr></table></figure>

<p>然后就可以得到如下的效果：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png" class="">

<p>（有关坐标空间的详细讲解，建议去看冯乐乐女神的shader入门精要）</p>
<h4 id="画立方体"><a href="#画立方体" class="headerlink" title="画立方体"></a>画立方体</h4><p>在LearnOpenGL官网把顶点直接复制之后，我们也照老规矩开始改Attribute：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//改为用array画</span></span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure>

<p>然后为了显示正确的图案，我们需要用到Z-Buffer，它实际上存储的是深度信息，用来判断物体与物体、物体的各个面之间的遮挡关系。GLFW会自动生成这样一个缓冲，深度值存储在每个片段里面（作为片段的<strong>z</strong>值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。想要使用深度测试时，我们只需要用<code>glEnable(GL_DEPTH_TEST)</code>去打开即可。</p>
<p>因为使用了深度测试，所以也需要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲。</p>
<blockquote>
<p>而在Unity中，深度测试对应的就是clear flag的depth only</p>
</blockquote>
<h4 id="画更多的立方体"><a href="#画更多的立方体" class="headerlink" title="画更多的立方体"></a>画更多的立方体</h4><p>先把十个立方体的位置信息给复制上去，然后我们调用glDrawArrays 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中，我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	glm::mat4 modelMat;</span><br><span class="line">	modelMat = glm::translate(modelMat, cubePositions[i]);</span><br><span class="line">	glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;modelMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(modelMat));</span><br><span class="line">	glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;viewMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(viewMat));</span><br><span class="line">	glUniformMatrix4fv(glad_glGetUniformLocation(myShader-&gt;ID, <span class="string">&quot;projMat&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::value_ptr(projMat));</span><br><span class="line"></span><br><span class="line">	glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以画出十个小箱子：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/6.png" class="">

<p>在这里就要提到DrawCall，drawcall是CPU对底层图形绘制接口的调用命令GPU执行渲染操作，每次绘制时，CPU都需要调用drawcall，每个drawcall都需要很多准备工作，检测渲染状态、提交渲染数据、提交渲染状态。而GPU本身具有很强大的计算能力，可以很快就处理完渲染任务。</p>
<p>但是当DrawCall过多，CPU就会很多额外开销用于准备工作，这里我们就使用了是个drawcall命令，所以我们要采取一个优化，只使用一个drawcall就画出这十个立方体。由于这篇文章的篇幅已经过大，我会在另外一篇文章给出具体的优化方法，就是<strong>基于GPU Instance实现大量物体的渲染和绘制</strong>。</p>
<hr>
<h3 id="摄像机（封装Camera-Class）"><a href="#摄像机（封装Camera-Class）" class="headerlink" title="摄像机（封装Camera Class）"></a>摄像机（封装Camera Class）</h3><p>OpenGL本身没有<strong>摄像机</strong>(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种<strong>我们</strong>在移动的感觉，而不是场景在移动。现在我来教你如何在OpenGL中配置一个摄像机，并且将会讨论FPS风格的摄像机，让你能够在3D场景中自由移动。也会讲键盘和鼠标输入，最终完成一个自定义的摄像机类。</p>
<h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，俯仰角是描述我们如何往上或往下看的角，偏航角表示我们往左和往右看的程度，滚转角代表我们如何<strong>翻滚</strong>摄像机。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量。对于摄像机系统来说，只需要对俯仰角和偏航角进行描述。</p>
<h4 id="LookAt矩阵"><a href="#LookAt矩阵" class="headerlink" title="LookAt矩阵"></a>LookAt矩阵</h4><p>我们获取摄像机的三个轴，再加上一个摄像机的位置向量，就可以得到摄像机的观察矩阵，首先我们可以得到摄像机的位置，然后用位置减去我们所定义的原点，就可以得到我们想得到的位置向量，再把位置向量和世界的Up向量做叉积，就可以得到指向右边的垂直向量，再把右边向量和位置向量叉乘就可以得到摄像机的up向量，于是这几个向量就都得到了。</p>
<p>我们创建一个Camera类，然后在构造函数里面进行赋值和计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Camera::Camera(glm::vec3 position, glm::vec3 target, glm::vec3 worldup)</span><br><span class="line">&#123;</span><br><span class="line">	Position = position;</span><br><span class="line">	WorldUp = worldup;</span><br><span class="line">	Forward = glm::normalize(target - position);</span><br><span class="line">	Right = glm::normalize((glm::cross(Forward, WorldUp)));</span><br><span class="line">	Up = glm::normalize(glm::cross(Forward, Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们直接用OpenGL的lookat方法就可以把这个矩阵给构造出来:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::mat4 <span class="title">Camera::GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> glm::lookAt(Position, Position + Forward, WorldUp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以把之前的view矩阵替换掉，<code>viewMat = camera.GetViewMatrix()</code>，并且把它放到渲染循环里面，这样就做出了摄像机的视角。</p>
<h4 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h4><p>之前的构造函数无法做出旋转量的改变，接下来做另外一个构造函数：<code>Camera(glm::vec3 position, float pitch, float yaw, glm::vec3 worldup)</code>。我们想要使用之前提到过的欧拉角的方式，来计算Camera的Forward向量的改变，具体的推导计算方法如下：</p>
<img src="/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.jpg" class="">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Camera::Camera(glm::vec3 position, <span class="keyword">float</span> pitch, <span class="keyword">float</span> yaw, glm::vec3 worldup)</span><br><span class="line">&#123;</span><br><span class="line">	Position = position;</span><br><span class="line">	WorldUp = worldup;</span><br><span class="line">	Pitch = pitch;</span><br><span class="line">	Yaw = yaw;</span><br><span class="line">	Forward.x = glm::<span class="built_in">cos</span>(Pitch) * glm::<span class="built_in">sin</span>(Yaw);</span><br><span class="line">	Forward.y = glm::<span class="built_in">sin</span>(Pitch);</span><br><span class="line">	Forward.z = glm::<span class="built_in">cos</span>(Pitch) * glm::<span class="built_in">cos</span>(Yaw);</span><br><span class="line">	Right = glm::normalize((glm::cross(Forward, WorldUp)));</span><br><span class="line">	Up = glm::normalize(glm::cross(Forward, Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="鼠标输入监听"><a href="#鼠标输入监听" class="headerlink" title="鼠标输入监听"></a>鼠标输入监听</h4><p>偏航角和俯仰角是通过鼠标移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。首先要告诉GLFW，它应该隐藏光标，并捕捉(Capture)它。我们使用<code>glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED)</code>就可以实现这个，直接把它放在开窗成功之后就行。</p>
<p>然后我们就要使用回调函数去监听鼠标的输入，<code>glfwSetCursorPosCallback(window, mouse_callback)</code>,这个函数会告诉OpenGL每当鼠标有输入就调用我们写的<code>mouse_callback</code>回调函数去对鼠标的输入做处理(这个函数是用来计算鼠标的移动量)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (firstMouse==<span class="literal">true</span>)</span><br><span class="line">	&#123;<span class="comment">//第一次输入时默认为0</span></span><br><span class="line">		lastX = xpos;</span><br><span class="line">		lastY = ypos;</span><br><span class="line">		firstMouse = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">float</span> deltaX, deltaY;</span><br><span class="line">	<span class="comment">//计算偏移量</span></span><br><span class="line">	deltaX = xpos - lastX;</span><br><span class="line">	deltaY = ypos - lastY;</span><br><span class="line"></span><br><span class="line">	lastX = xpos;</span><br><span class="line">	lastY = ypos;</span><br><span class="line">	</span><br><span class="line">	camera.ProcessMouseMovement(deltaX, deltaY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在把得到的偏移量用于更新Camera的Forward向量，其中deltaX对应的是水平偏移量Yaw，deltaY对应的是俯仰角偏移量Pitch：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera::ProcessMouseMovement</span><span class="params">(<span class="keyword">float</span> deltaX, <span class="keyword">float</span> deltaY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pitch -= deltaY * SenseX;</span><br><span class="line">	Yaw -= deltaX * SenseY;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Pitch&gt;<span class="number">89.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Pitch = <span class="number">89.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Pitch&lt;<span class="number">-89.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Pitch = <span class="number">-89.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	UpdateCameraVectors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera::UpdateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Forward.x = glm::<span class="built_in">cos</span>(glm::radians(Pitch)) * glm::<span class="built_in">sin</span>(glm::radians(Yaw));</span><br><span class="line">	Forward.y = glm::<span class="built_in">sin</span>(glm::radians(Pitch));</span><br><span class="line">	Forward.z = glm::<span class="built_in">cos</span>(glm::radians(Pitch)) * glm::<span class="built_in">cos</span>(glm::radians(Yaw));</span><br><span class="line">	Right = glm::normalize((glm::cross(Forward, WorldUp)));</span><br><span class="line">	Up = glm::normalize(glm::cross(Forward, Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把鼠标的偏移套接到摄像机的Forward后，我们来实现FPS的视角移动，我们需要自定义前方，而这个前方就是之前组装出来的Forward，当我们按下W或者S时，在Forward上乘上一个数值就行。然后就是当我们按下A或者D的时候就使用刚刚计算得到的Right向量就可以以同样的方式去实现在一个平面上的左右移动。</p>
<p>在Camera.h里面定义speedZ和speedY，然后在ProcessInput里面去监听键盘的输入，再分别给刚刚的两个变量赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">		glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) &#123;</span><br><span class="line">		camera.speedZ = <span class="number">1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) &#123;</span><br><span class="line">		camera.speedZ = <span class="number">-1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">		camera.speedY = <span class="number">-1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">		camera.speedY = <span class="number">1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		camera.speedZ = <span class="number">0</span>;</span><br><span class="line">		camera.speedY = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Camera::UpdateCameraPos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//用前和右向量去调变摄像机的位置</span></span><br><span class="line">	Position += Forward * speedZ * <span class="number">0.1f</span>;</span><br><span class="line">	Position += Right * speedY * <span class="number">0.1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，FPS的移动方式我们也已经实现了!</p>
<p>Graphics is awesome！未完待续。。。。。</p>
<p>​                                              </p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">cdc</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://higashisan.github.io/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">https://higashisan.github.io/2020/03/19/OpenGL-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">cdc</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/OpenGL/">
                                    <span class="chip bg-color">OpenGL</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2020/03/27/OpenGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%85%89%E7%85%A7/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="OpenGL学习记录：光照">
                        
                        <span class="card-title">OpenGL学习记录：光照</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-03-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            cdc
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/OpenGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%85%89%E7%85%A7/">
                        <span class="chip bg-color">OpenGL学习记录：光照</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/03/08/%E5%AF%B9Tessellaion%E5%92%8CGeometryShader%E7%9A%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Tessellation Shader的底层实现">
                        
                        <span class="card-title">Tessellation Shader的底层实现</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            cdc
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Tessellation-Shader/">
                        <span class="chip bg-color">Tessellation Shader</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="8194788712"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='false'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">cdc</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2923642767@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2923642767" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2923642767" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
